<!--
Copyright 2020 Google Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<!-- Custom client-side JavaScript code. -->
<!DOCTYPE html>
<script>
  let googleScriptRun = google.script.run
    .withFailureHandler((error) => alert(`Error occured: ${error.message}`));

  const projectParameters = {
    mapCenter: { lat: 51.5755855, lng: 7.643094500000004 },
    customRadius: 5,
    colors: {
      lightGray: "#aaa",
      red: "#f00",
      green: "#0f0",
    },
    unwantedString: "BOMSquare",
    fileSuffix: "-calculated.csv",
    polygon: {
      strokeOpacity: 0.8,
      strokeWeight: 2,
      fillOpacity: 0.35,
    },
    circle: {
      strokeOpacity: 0.8,
      strokeWeight: 2,
      fillOpacity: 0.35,
    },
    csvConfig: {
      accountId: "[Insert-your-account-id]",
      campaignName: "[Insert-your-campaign-name]",
      radiusUnit: "km", // km -> mi conversion is not yet supported
      intersectionTreshold: 90,
      minRadius: 3,
    },
  };

  let globalCodeName;
  let globalUnionPolygonArea;
  let globalSquareCoords;
  let globalCenter = projectParameters.mapCenter;
  let globalMap;
  let globalBusinessSize;
  let globalRectangle;
  let globalSmallCircle;
  let globalLargeCircle;
  let globalCustomRadius = projectParameters.customRadius;
  let globalPolygonsMap;
  let globalCustomCircle;
  let filename = "";

  let globalLocationsMap = {};

  function initMap() {
    globalMap = new google.maps.Map(document.getElementById('map'), {
      zoom: 10,
      center: projectParameters.mapCenter,
      mapTypeId: google.maps.MapTypeId.TERRAIN,
    });
    googleScriptRun.withSuccessHandler(initMap);
  }

  function updateUI(polygon) {
    setUpGlobalVariables(polygon);
    updateCheckboxes();
    updateInnerHTML();
    updateSelectedCircleRadio();
  }

  function setUpGlobalVariables(polygon) {
    globalUnionPolygonArea = getPolygonAreaFromJtst(globalMap, polygon);
    globalSquareCoords = getSquareCoords(getPolygonPoints(globalUnionPolygonArea));
    globalCenter = getCenter(globalSquareCoords);
    globalMap.setCenter(globalCenter);
    globalBusinessSize = getPolygonSize(globalUnionPolygonArea);
  }

  function updateInnerHTML() {
    updateGlobalBusinessInnerHTML();
    updateAllCirclesInnerHTML();
  }

  function updateGlobalBusinessInnerHTML() {
    const businessCenter = getCenter(globalSquareCoords);
    document.getElementById('text_under_map_business').innerHTML = globalBusinessSize.toFixed(2) + ' km<sup>2</sup>';
    document.getElementById('circle_center_coordinates').innerHTML =
      `lat: ${businessCenter.lat}, lng: ${businessCenter.lng}`;
  }

  function updateAllCirclesInnerHTML() {
    const circleTypes = ['large', 'small', 'threshold', 'custom'];

    for (let i=0; i<circleTypes.length; i++) {
      updateCircleInnerHtml(circleTypes[i]);
    }
  }

  function updateCircleInnerHtml(circleType) {
    let circleData = globalLocationsMap[globalCodeName][`${circleType}Circle`];
    let radius = circleData.radius;
    let circleSize = circleData.size;
    let intersectionSize = circleData.intersectionSize;
    let intersectionPercent = circleData.intersectionPercent;
    let wasteSize = circleData.wasteSize;
    let wastePercent = circleData.wastePercent;
    let score = circleData.score;

    document.getElementById(`text_under_map_${circleType}_radius`).innerHTML = `${radius} km`;
    document.getElementById(`text_under_map_${circleType}_size`).innerHTML = circleSize + ' km<sup>2</sup>';
    document.getElementById(`text_under_map_${circleType}`).innerHTML = intersectionSize + ' km<sup>2</sup>';
    document.getElementById(`text_under_map_${circleType}_percent`).innerHTML = `${intersectionPercent}%`;
    document.getElementById(`text_under_map_${circleType}_waste`).innerHTML = wasteSize + ' km<sup>2</sup>';
    document.getElementById(`text_under_map_${circleType}_waste_percent`).innerHTML = `${wastePercent}%`;
    document.getElementById(`text_under_map_${circleType}_score`).innerHTML = score;

    if (circleType == 'custom') {
      // Update Custom Radius in Slider
      document.getElementById('radius').innerHTML = `${radius} km`;

      // Update Custom Circle in Map
      updateCustomCircleCheckbox();
    }
  }

  /* Select aka dropdown */
  function addMenuListItems(codenames) {
    const cityListSelect = document.getElementById('city-list-select');
    for (const codename of codenames) {
      let option = document.createElement('option');
      option.text = codename;
      cityListSelect.add(option);
    }
  }

  function updatedSelectedOptions(codename) {
    globalCodeName = codename;
    updateUI(unionOfPolygons(globalPolygonsMap.get(codename)));
  }

  /* Dialogs */

  const dialogUpload = document.querySelector('#dialog-upload');
  const showDialogButtonUpload = document.querySelector('#show-dialog-upload');

  if (!dialogUpload.showModal) {
    dialogPolyfill.registerDialog(dialogUpload); // where's dialogPolyfil defined?
  }
  showDialogButtonUpload.addEventListener('click', function () {
    dialogUpload.showModal();
  });

  dialogUpload.querySelector('.close').addEventListener('click', () => { closeDialog(); });

  document.getElementById('uploadKmlBtn').addEventListener('click', () => {
    document.getElementById('uploadKmlBtn').disabled = true;
    document.getElementById('upload-spinner').classList.add('is-active');

    const filesUploaded = document.getElementById('kmlFileUploadBtn');
    for (const file of filesUploaded.files) {
      filename = file.name;
      let reader = new FileReader();
      reader.readAsText(file, 'UTF-8');
      reader.onload = function (evt) {
        const xml = evt.target.result;
        googleScriptRun
          .withSuccessHandler(parseContentJsonObject).parseXml(xml)
          .withFailureHandler((error) => alert(`Error occured: ${error.message}`));;
      }
    }
  });

  function parseContentJsonObject(object) {
    globalPolygonsMap = mapPolygonsToNameAndCoordinates(object);
    globalCodeName = globalPolygonsMap.keys().next().value;
    closeDialog();

    populateLocationsMap(globalPolygonsMap);

    drawAllPolygons(globalPolygonsMap);
    addMenuListItems(globalPolygonsMap.keys());

    const unionPolygon = unionOfPolygons(globalPolygonsMap.values().next().value);
    updateUI(unionPolygon);
  }

  function populateLocationsMap() {
    globalPolygonsMap.forEach( (polygon, key, map) => {
      locationUnionPolygonArea = getPolygonAreaFromJtst(globalMap, unionOfPolygons(polygon));
      locationSquareCoords = getSquareCoords(getPolygonPoints(locationUnionPolygonArea));
      locationCenter = getCenter(locationSquareCoords);

      let location = {
        'center': locationCenter,
        'largeCircle': getCircle(getLargeRadius(locationSquareCoords), locationSquareCoords, locationUnionPolygonArea),
        'smallCircle': getCircle(getSmallRadius(locationSquareCoords), locationSquareCoords, locationUnionPolygonArea),
        'thresholdCircle': getCircle(getThresholdRadius(polygon) * 1000, locationSquareCoords, locationUnionPolygonArea),
        'customCircle': getCircle(projectParameters.customRadius * 1000, locationSquareCoords, locationUnionPolygonArea),
        'selected': 'thresholdCircle',
      };

      globalLocationsMap[key] = location;
    });
  }

  function getCircle(radius, squareCoords, polygonArea) {
    const center = getCenter(squareCoords);
    const businessSize = getPolygonSize(polygonArea);

    const circleCoords = convertCircleToPolygon(center, radius, 360 * 2);
    const circleArea = getPolygonArea(circleCoords,
      projectParameters.colors.lightGray,
      projectParameters.colors.lightGray
    );

    const circleSize =+ getIntersectionSize(circleArea, circleArea).toFixed(2);
    const intersectionSize =+ getIntersectionSize(polygonArea, circleArea).toFixed(2);
    const intersectionPercent =
      +(100 * getIntersectionSize(polygonArea, circleArea) / businessSize).toFixed(2);
    const wasteSize = +(circleSize - getIntersectionSize(polygonArea, circleArea)).toFixed(2);
    const wastePercent = +(100 * wasteSize / businessSize).toFixed(2);
    const score = +(intersectionPercent - wastePercent).toFixed(2);

    return {
      'radius': +(radius/1000).toFixed(1),  // radius in kms
      'size': circleSize,
      'intersectionPercent': intersectionPercent,
      'intersectionSize': intersectionSize,
      'wastePercent': wastePercent,
      'wasteSize': wasteSize,
      'score': score,
    };
  }

  function downloadRecommendations() {
    createCsvFileAndDownload(filename, globalLocationsMap);
  }

  function mapPolygonsToNameAndCoordinates(object) {
    const placemarks = object.kml.Document.Folder.Placemark;
    removeUnwantedPlacemarks(placemarks, projectParameters.unwantedString);
    const resultMap = new Map(placemarks.map(placemark =>
      [placemark.name.Text.substring(0, 3), []]));
    placemarks.map(
      placemark => (resultMap.get(placemark.name.Text.substring(0, 3)))
        .push(getPolygonArea(parseCoordsToLatLng(
          placemark.Polygon.outerBoundaryIs.LinearRing.coordinates.Text),
          projectParameters.colors.red,
          projectParameters.colors.red
        )));
    return resultMap;
  }

  function removeUnwantedPlacemarks(placemarks, name) {
    const namesPlacemarks = placemarks.map(placemark => placemark.name.Text);
    const index = namesPlacemarks.indexOf(name);
    if (index > -1) {
      placemarks.splice(index, 1);
    }
  }

  function parseCoordsToLatLng(coords) {
    const latLngCoords = [];
    const coordsSplit = coords.split(',0');
    for (let j = 0; j < coordsSplit.length - 1; j++) {
      const [lng, lat] = coordsSplit[j].split(",");
      latLngCoords.push({ lat: parseFloat(lat), lng: parseFloat(lng) });
    }
    return latLngCoords;
  }

  function closeDialog() {
    let dialog = document.querySelector('#dialog-upload');
    document.getElementById('upload-spinner').classList.remove('is-active');
    dialog.close();
  }

  function drawAllPolygons(polygonsMap) {
    let polygon;
    for (const codename of polygonsMap.keys()) {
      polygon = unionOfPolygons(polygonsMap.get(codename));
      drawPolygon(getJtstCoords(polygon), projectParameters.colors.red, globalMap);
    }
  }

  // Merge multiple polygons into one
  function unionOfPolygons(polygonAreas) {
    const geometryFactory = new jsts.geom.GeometryFactory();
    let unionPolygon = createJstsPolygon(geometryFactory, polygonAreas[0]);
    for (let i = 1; i < polygonAreas.length; i++) {
      let jstsPolygon = createJstsPolygon(geometryFactory, polygonAreas[i]);
      unionPolygon = unionPolygon.union(jstsPolygon);
    }
    return unionPolygon;
  };

  function getPolygonAreaFromJtst(map, jtstPolygon) {
    const coords = jtstPolygon.getCoordinates().map((coord) => {
      return { lat: coord.x, lng: coord.y };
    });
    return getPolygonArea(coords, projectParameters.colors.green, map);
  }

  function getJtstCoords(jtstPolygon) {
    const coords = jtstPolygon.getCoordinates().map((coord) => {
      return { lat: coord.x, lng: coord.y };
    });
    return coords;
  }


  // Slider
  function calculateCustomFields(radius) {
    globalCustomRadius = radius;

    let degrees = 360;
    if (radius > 5) {
      degrees = degrees * 2;
    }

    locationSquareCoords = getSquareCoords(getPolygonPoints(globalUnionPolygonArea));
    globalLocationsMap[globalCodeName].customCircle = getCircle(radius * 1000, locationSquareCoords, globalUnionPolygonArea)
    updateCircleInnerHtml("custom");
  }

  // Called from Radio Button UI
  function updateSelectedCircle() {
    const circleType = document.querySelector('input[name="selectedTargeting"]:checked').value;
    globalLocationsMap[globalCodeName].selected = circleType;
  }

  // Update the checked value of the Selected Settings Radio Buttons
  function updateSelectedCircleRadio() {
    const circleType = globalLocationsMap[globalCodeName].selected;
    document.getElementById(`${circleType}Radio`).checked = true;
  }

  // Checkboxes
  function updateCheckboxes() {
    updateCustomCircleCheckbox();
    updateRectanlgeCheckbox();
    updateSmallCircleCheckbox();
    updateLargeCircleCheckbox();
  }

  function updateRectanlgeCheckbox() {
    const myCheckbox = document.getElementById('rectangleCheckbox');
    safeRemoveRectangle(globalRectangle);
    if (myCheckbox.checked) {
      globalRectangle = drawPolygon(globalSquareCoords, projectParameters.colors.lightGray, globalMap);
    }
  }

  function updateSmallCircleCheckbox() {
    const myCheckbox = document.getElementById('smallCheckbox');
    safeRemoveCircle(globalSmallCircle);
    if (myCheckbox.checked) {
      globalSmallCircle = drawSmallCircle(globalSquareCoords, projectParameters.colors.lightGray, globalMap);
    }
  }

  function updateLargeCircleCheckbox() {
    const myCheckbox = document.getElementById('largeCheckbox');
    safeRemoveCircle(globalLargeCircle);
    if (myCheckbox.checked) {
      globalLargeCircle = drawLargeCircle(globalSquareCoords, projectParameters.colors.lightGray, globalMap);
    }
  }

  function updateCustomCircleCheckbox() {
    const myCheckbox = document.getElementById('customCheckbox');
    safeRemoveCircle(globalCustomCircle);
    if (myCheckbox.checked) {
      globalCustomCircle =
        drawCircle(getCenter(globalSquareCoords), globalCustomRadius * 1000, projectParameters.colors.lightGray, globalMap);
    }
  }

  function safeRemoveCircle(globalCircleShape) {
    if (globalCircleShape !== undefined) {
      globalCircleShape = removeCircle(globalCircleShape);
    }
  }

  function safeRemoveRectangle(globalRectangleShape) {
    if (globalRectangleShape !== undefined) {
      globalRectangleShape = removePolygon(globalRectangleShape);
    }
  }

  // Intersection & Polygon
  function getIntersectionSize(polygonAreaA, polygonAreaB) {
    const intersection = getIntersection(polygonAreaA, polygonAreaB);
    const intersectionPoints = convertToPoints(intersection);
    return 10000 * d3.polygonArea(intersectionPoints);
  }

  function getIntersection(polygonAreaA, polygonAreaB) {
    const geometryFactory = new jsts.geom.GeometryFactory();
    const jstsPolygonA = createJstsPolygon(geometryFactory, polygonAreaA);
    const jstsPolygonB = createJstsPolygon(geometryFactory, polygonAreaB);
    return jstsPolygonA.intersection(jstsPolygonB);
  }

  function createJstsPolygon(geometryFactory, polygon) {
    const path = polygon.getPath();
    const coordinates = path.getArray().map((coord) => {
      return new jsts.geom.Coordinate(coord.lat(), coord.lng());
    });
    coordinates.push(coordinates[0]);
    const shell = geometryFactory.createLinearRing(coordinates);
    return geometryFactory.createPolygon(shell);
  }

  function convertToPoints(polygon) {
    const coords = polygon.getCoordinates().map((coord) => {
      return [coord.x + 90, coord.y + 180];
    });
    return coords;
  }

  function drawPolygon(coordArray, color, map) {
    const polygonArea = getPolygonArea(coordArray, color, color);
    polygonArea.setMap(map);
    return polygonArea;
  }

  function getPolygonArea(paths, strokeColor, fillColor) {
    const polygonArea = new google.maps.Polygon({
      paths,
      strokeColor,
      strokeOpacity: projectParameters.polygon.strokeOpacity,
      strokeWeight: projectParameters.polygon.strokeWeight,
      fillColor,
      fillOpacity: projectParameters.polygon.fillOpacity
    });
    return polygonArea;
  }

  function getPolygonSize(polygonArea) {
    const points = getPolygonPoints(polygonArea);
    const areaSize = 10000 * d3.polygonArea(points);
    return areaSize;
  }

  function getPolygonPoints(polygonArea) {
    const geometryFactory = new jsts.geom.GeometryFactory();
    const jstsPolygon = createJstsPolygon(geometryFactory, polygonArea);
    const points = convertToPoints(jstsPolygon);
    return points;
  }

  function removePolygon(polygonArea) {
    polygonArea.setMap(null);
    return polygonArea;
  }

  //square
  function getSquareCoords(points) {
    let minLat = points[0][0];
    let minLng = points[0][1];
    let maxLat = points[0][0];
    let maxLng = points[0][1];

    for (let i = 1; i < points.length; i++) {
      minLat = Math.min(minLat, points[i][0]);
      maxLat = Math.max(maxLat, points[i][0]);
      minLng = Math.min(minLng, points[i][1]);
      maxLng = Math.max(maxLng, points[i][1]);
    }
    const squareCoords = [
      { lat: minLat - 90, lng: maxLng - 180 }, // 1
      { lat: maxLat - 90, lng: maxLng - 180 }, // 2 or NE
      { lat: maxLat - 90, lng: minLng - 180 }, // 3
      { lat: minLat - 90, lng: minLng - 180 }  // 4 or SW
    ];
    return squareCoords;
  }

  // Circles
  function drawLargeCircle(coords, color, map) {
    return drawCircle(getCenter(coords), getLargeRadius(coords), color, map);
  }

  function drawSmallCircle(coords, color, map) {
    return drawCircle(getCenter(coords), getSmallRadius(coords), color, map);
  }

  function drawCircle(center, radius, color, map) {
    const circle = new google.maps.Circle({
      strokeColor: color,
      strokeOpacity: projectParameters.circle.strokeOpacity,
      strokeWeight: projectParameters.circle.strokeWeight,
      fillColor: color,
      fillOpacity: projectParameters.circle.fillOpacity,
      map,
      center,
      radius,
    });
    return circle;
  }

  function removeCircle(circle) {
    circle.setMap(null);
    return circle;
  }

  function getCenter(squareCoords) {
    const centerLat = (squareCoords[1].lat + squareCoords[3].lat) / 2;
    const centerLng = (squareCoords[1].lng + squareCoords[3].lng) / 2
    const center = { lat: centerLat, lng: centerLng };
    return center;
  }

  function getLargeRadius(squareCoords) {
    const circleCenter = getCenter(squareCoords);
    const squarePoint = new google.maps.LatLng(squareCoords[0].lat, squareCoords[0].lng);
    const circlePoint = new google.maps.LatLng(circleCenter.lat, circleCenter.lng);
    const distance = google.maps.geometry.spherical.computeDistanceBetween(squarePoint,
      circlePoint);
    return distance;
  }

  function getSmallRadius(squareCoords) {
    const circleCenter = getCenter(squareCoords);
    const squarePoint = new google.maps.LatLng(circleCenter.lat, squareCoords[0].lng);
    const circlePoint = new google.maps.LatLng(circleCenter.lat, circleCenter.lng);
    const distance = google.maps.geometry.spherical.computeDistanceBetween(squarePoint,
      circlePoint);
    return distance;
  }

  function getThresholdRadius(polygon) {
    const unionPolygonArea = getPolygonAreaFromJtst(globalMap,
      unionOfPolygons(polygon));
    const center = getCenter(getSquareCoords(getPolygonPoints(unionPolygonArea)));
    const polygonSize = getPolygonSize(unionPolygonArea);
    const intersectionTreshold = projectParameters.csvConfig.intersectionTreshold;
    const minRadius = projectParameters.csvConfig.minRadius;
    const maxRadius = getLargeRadius(getSquareCoords(getPolygonPoints(unionPolygonArea))) / 1000;

    let thresholdRadius = 0;
    let i = minRadius;

    while (i < maxRadius) {
      let circleArea = getPolygonArea(
        convertCircleToPolygon(center, i * 1000, 360 * 2),
        projectParameters.colors.lightGray,
        projectParameters.colors.lightGray
      );

      let intersectionSize = getIntersectionSize(unionPolygonArea, circleArea);
      let intersectionPercent = (100 * intersectionSize / polygonSize).toFixed(2);

      if (intersectionPercent > intersectionTreshold) {
        thresholdRadius = i;
        break;
      }
      i = parseFloat((i + 0.1).toFixed(1));
    }

    return thresholdRadius;
  }

  function convertCircleToPolygon(center, radius, num) {
    const points = [];
    const degreeStep = 360 / num;

    for (let i = 0; i < num; i++) {
      const gpos = google.maps.geometry.spherical.computeOffset(
        new google.maps.LatLng(center), radius, degreeStep * i);
      points.push({ lat: gpos.lat(), lng: gpos.lng() });
    };

    points.push(points[0]);
    return points;
  }

  function createCsvFileAndDownload(filename, locations) {
    const csvFileName = removeExtension(filename) + projectParameters.fileSuffix;
    const csvLines = createCsvContent(locations);
    const csvContent = csvLines.join('\n');
    createFileAndDownload(csvContent, csvFileName);
  }

  function createCsvContent(locations) {
    const minRadius = projectParameters.csvConfig.minRadius;
    const intersectionTreshold = projectParameters.csvConfig.intersectionTreshold;
    const csvLines = [getCsvHeader()];

    Object.keys(locations).forEach(key => {
      const locationData = locations[key];

      let csvLine = [];
      csvLine.push(projectParameters.csvConfig.accountId);
      csvLine.push(projectParameters.csvConfig.campaignName);
      csvLine.push(`${locationData[locationData.selected].radius}${projectParameters.csvConfig.radiusUnit}:${locationData.center.lat}:${locationData.center.lng}`);
      csvLine.push(locationData[locationData.selected].radius);
      csvLine.push(projectParameters.csvConfig.radiusUnit);

      csvLines.push(csvLine.join(','));
    });

    return csvLines;
  }

  /* File Helpers */
  function createFileAndDownload(fileText, filename) {
    const element = document.createElement('a');
    const blob = new Blob([fileText], { type: 'text/plain' });

    element.setAttribute('href', window.URL.createObjectURL(blob));
    element.setAttribute('download', filename);

    element.dataset.downloadurl =
      ['text/plain', element.download, element.href].join(':');
    element.draggable = true;
    element.classList.add('dragout');
    element.click();
  }

  function createCsvLine(accountId, campaignName, tresholdString) {
    return `${accountId}, ${campaignName}, ${tresholdString}`;
  }

  function getCsvHeader() {
    return "Account ID, Campaign, Location, Radius, Unit";
  }

  function removeExtension(filename) {
    const filenameParts = filename.split('.');
    filenameParts.pop();
    return filenameParts.join('.');
  }

</script>
<script src='https://maps.googleapis.com/maps/api/js?libraries=visualization,drawing,geometry&callback=initMap&key=[INSERT-API-KEY]' async defer></script>